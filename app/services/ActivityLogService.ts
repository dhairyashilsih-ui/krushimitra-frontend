import AsyncStorage from '@react-native-async-storage/async-storage';

// Activity Log Interface
export interface ActivityLog {
  id: string;
  timestamp: Date;
  farmLocation: string;
  featureUsed: string;
  activityType: string;
  activityDetails: string;
  status: 'completed' | 'in_progress' | 'failed' | 'pending';
  aiRemarks?: string;
  additionalData?: any;
  isAutoGenerated: boolean;
  syncStatus: 'synced' | 'pending' | 'failed';
}

export interface ActivityLogInput {
  farmLocation: string;
  featureUsed: string;
  activityType: string;
  activityDetails: string;
  status?: 'completed' | 'in_progress' | 'failed' | 'pending';
  aiRemarks?: string;
  additionalData?: any;
  isAutoGenerated?: boolean;
}

class ActivityLogService {
  private static instance: ActivityLogService;
  private readonly STORAGE_KEY = 'activity_logs';
  private readonly SYNC_QUEUE_KEY = 'sync_queue';
  private logs: ActivityLog[] = [];
  private syncQueue: string[] = [];

  private constructor() {
    this.loadLogsFromStorage();
  }

  public static getInstance(): ActivityLogService {
    if (!ActivityLogService.instance) {
      ActivityLogService.instance = new ActivityLogService();
    }
    return ActivityLogService.instance;
  }

  /**
   * Add a new activity log entry
   */
  public async addLog(input: ActivityLogInput): Promise<string> {
    const logId = this.generateLogId();
    
    const newLog: ActivityLog = {
      id: logId,
      timestamp: new Date(),
      farmLocation: input.farmLocation || 'Unknown Farm',
      featureUsed: input.featureUsed,
      activityType: input.activityType,
      activityDetails: input.activityDetails,
      status: input.status || 'completed',
      aiRemarks: input.aiRemarks,
      additionalData: input.additionalData,
      isAutoGenerated: input.isAutoGenerated || false,
      syncStatus: 'pending'
    };

    this.logs.unshift(newLog); // Add to beginning for newest first
    this.syncQueue.push(logId);
    
    await this.saveLogsToStorage();
    await this.saveSyncQueue();
    
    // Auto-sync if online (simulate)
    this.attemptSync();
    
    return logId;
  }

  /**
   * Get all logs with optional filtering
   */
  public getLogs(filters?: {
    farm?: string;
    feature?: string;
    dateRange?: 'today' | 'week' | 'month' | 'all';
    status?: string;
    searchQuery?: string;
  }): ActivityLog[] {
    let filteredLogs = [...this.logs];

    if (filters) {
      // Farm filter
      if (filters.farm && filters.farm !== 'all') {
        filteredLogs = filteredLogs.filter(log => 
          log.farmLocation.toLowerCase().includes(filters.farm!.toLowerCase())
        );
      }

      // Feature filter
      if (filters.feature && filters.feature !== 'all') {
        filteredLogs = filteredLogs.filter(log => log.featureUsed === filters.feature);
      }

      // Date range filter
      if (filters.dateRange && filters.dateRange !== 'all') {
        const now = new Date();
        const filterDate = new Date();
        
        switch (filters.dateRange) {
          case 'today':
            filterDate.setHours(0, 0, 0, 0);
            break;
          case 'week':
            filterDate.setDate(now.getDate() - 7);
            break;
          case 'month':
            filterDate.setMonth(now.getMonth() - 1);
            break;
        }
        
        filteredLogs = filteredLogs.filter(log => log.timestamp >= filterDate);
      }

      // Status filter
      if (filters.status && filters.status !== 'all') {
        filteredLogs = filteredLogs.filter(log => log.status === filters.status);
      }

      // Search query filter
      if (filters.searchQuery) {
        const query = filters.searchQuery.toLowerCase();
        filteredLogs = filteredLogs.filter(log => 
          log.activityDetails.toLowerCase().includes(query) ||
          log.featureUsed.toLowerCase().includes(query) ||
          log.farmLocation.toLowerCase().includes(query) ||
          log.activityType.toLowerCase().includes(query) ||
          (log.aiRemarks && log.aiRemarks.toLowerCase().includes(query))
        );
      }
    }

    return filteredLogs.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
  }

  /**
   * Get a specific log by ID
   */
  public getLogById(id: string): ActivityLog | null {
    return this.logs.find(log => log.id === id) || null;
  }

  /**
   * Update a log's status
   */
  public async updateLogStatus(id: string, status: ActivityLog['status'], aiRemarks?: string): Promise<boolean> {
    const logIndex = this.logs.findIndex(log => log.id === id);
    if (logIndex === -1) return false;

    this.logs[logIndex].status = status;
    if (aiRemarks) {
      this.logs[logIndex].aiRemarks = aiRemarks;
    }
    this.logs[logIndex].syncStatus = 'pending';
    
    if (!this.syncQueue.includes(id)) {
      this.syncQueue.push(id);
    }

    await this.saveLogsToStorage();
    await this.saveSyncQueue();
    this.attemptSync();

    return true;
  }

  /**
   * Get statistics about logs
   */
  public getStats(): {
    total: number;
    today: number;
    autoGenerated: number;
    pendingSync: number;
    byFeature: Record<string, number>;
    byStatus: Record<string, number>;
  } {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const stats = {
      total: this.logs.length,
      today: this.logs.filter(log => log.timestamp >= today).length,
      autoGenerated: this.logs.filter(log => log.isAutoGenerated).length,
      pendingSync: this.logs.filter(log => log.syncStatus === 'pending').length,
      byFeature: {} as Record<string, number>,
      byStatus: {} as Record<string, number>
    };

    // Count by feature
    this.logs.forEach(log => {
      stats.byFeature[log.featureUsed] = (stats.byFeature[log.featureUsed] || 0) + 1;
      stats.byStatus[log.status] = (stats.byStatus[log.status] || 0) + 1;
    });

    return stats;
  }

  /**
   * Clear all logs (for testing/reset)
   */
  public async clearAllLogs(): Promise<void> {
    this.logs = [];
    this.syncQueue = [];
    await AsyncStorage.removeItem(this.STORAGE_KEY);
    await AsyncStorage.removeItem(this.SYNC_QUEUE_KEY);
  }

  /**
   * Load logs from AsyncStorage
   */
  private async loadLogsFromStorage(): Promise<void> {
    try {
      const storedLogs = await AsyncStorage.getItem(this.STORAGE_KEY);
      const storedSyncQueue = await AsyncStorage.getItem(this.SYNC_QUEUE_KEY);
      
      if (storedLogs) {
        const parsedLogs = JSON.parse(storedLogs);
        // Convert timestamp strings back to Date objects
        this.logs = parsedLogs.map((log: any) => ({
          ...log,
          timestamp: new Date(log.timestamp)
        }));
      }

      if (storedSyncQueue) {
        this.syncQueue = JSON.parse(storedSyncQueue);
      }
    } catch (error) {
      console.error('Error loading logs from storage:', error);
      this.logs = [];
      this.syncQueue = [];
    }
  }

  /**
   * Save logs to AsyncStorage
   */
  private async saveLogsToStorage(): Promise<void> {
    try {
      await AsyncStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.logs));
    } catch (error) {
      console.error('Error saving logs to storage:', error);
    }
  }

  /**
   * Save sync queue to AsyncStorage
   */
  private async saveSyncQueue(): Promise<void> {
    try {
      await AsyncStorage.setItem(this.SYNC_QUEUE_KEY, JSON.stringify(this.syncQueue));
    } catch (error) {
      console.error('Error saving sync queue to storage:', error);
    }
  }

  /**
   * Generate unique log ID
   */
  private generateLogId(): string {
    return `log_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
  }

  /**
   * Attempt to sync pending logs to server
   */
  private async attemptSync(): Promise<void> {
    // Simulate sync attempt - in real app, this would make API calls
    try {
      // Check if online (simulate)
      const isOnline = true; // navigator.onLine or NetInfo in React Native
      
      if (!isOnline || this.syncQueue.length === 0) return;

      // Simulate successful sync for pending logs
      const syncPromises = this.syncQueue.map(async (logId) => {
        const log = this.logs.find(l => l.id === logId);
        if (log) {
          // Simulate API call delay
          await new Promise(resolve => setTimeout(resolve, 500));
          log.syncStatus = 'synced';
          return logId;
        }
        return null;
      });

      const syncedLogIds = await Promise.all(syncPromises);
      
      // Remove synced logs from queue
      this.syncQueue = this.syncQueue.filter(id => !syncedLogIds.includes(id));
      
      await this.saveLogsToStorage();
      await this.saveSyncQueue();
      
    } catch (error) {
      console.error('Sync failed:', error);
      // Mark failed logs
      this.syncQueue.forEach(logId => {
        const log = this.logs.find(l => l.id === logId);
        if (log) {
          log.syncStatus = 'failed';
        }
      });
      await this.saveLogsToStorage();
    }
  }

  /**
   * Force sync all pending logs
   */
  public async forceSyncAll(): Promise<boolean> {
    try {
      await this.attemptSync();
      return this.syncQueue.length === 0;
    } catch (error) {
      console.error('Force sync failed:', error);
      return false;
    }
  }
}

// Convenience functions for automatic logging from different features

export const logCropDiseaseDetection = async (
  farmLocation: string,
  diseaseDetected: string,
  confidence: number,
  recommendations: string
): Promise<string> => {
  const service = ActivityLogService.getInstance();
  return service.addLog({
    farmLocation,
    featureUsed: 'Crop Disease Detection',
    activityType: 'Disease Scan',
    activityDetails: `Scanned crops for disease detection. Detected: ${diseaseDetected}`,
    aiRemarks: `${diseaseDetected} detected with ${confidence}% confidence. ${recommendations}`,
    isAutoGenerated: true,
    additionalData: {
      diseaseDetected,
      confidence,
      recommendations
    }
  });
};

export const logMandiPriceCheck = async (
  farmLocation: string,
  crop: string,
  currentPrice: number,
  previousPrice?: number
): Promise<string> => {
  const service = ActivityLogService.getInstance();
  const priceChange = previousPrice ? ((currentPrice - previousPrice) / previousPrice * 100).toFixed(1) : '0';
  
  return service.addLog({
    farmLocation,
    featureUsed: 'Mandi Prices',
    activityType: 'Price Check',
    activityDetails: `Checked current market prices for ${crop}`,
    aiRemarks: `Current price: â‚¹${currentPrice}/quintal. ${previousPrice ? `${parseFloat(priceChange) >= 0 ? '+' : ''}${priceChange}% from last check.` : ''}`,
    isAutoGenerated: true,
    additionalData: {
      crop,
      currentPrice,
      previousPrice,
      priceChange: parseFloat(priceChange)
    }
  });
};

export const logGovernmentSchemeCheck = async (
  farmLocation: string,
  schemeName: string,
  eligibilityStatus: 'eligible' | 'not_eligible' | 'pending',
  benefits?: string
): Promise<string> => {
  const service = ActivityLogService.getInstance();
  return service.addLog({
    farmLocation,
    featureUsed: 'Government Schemes',
    activityType: 'Scheme Check',
    activityDetails: `Checked eligibility for ${schemeName} scheme`,
    aiRemarks: eligibilityStatus === 'eligible' 
      ? `Eligible for ${schemeName}. ${benefits || ''}`
      : eligibilityStatus === 'not_eligible'
      ? `Not eligible for ${schemeName} at this time.`
      : `Eligibility pending verification for ${schemeName}.`,
    isAutoGenerated: true,
    additionalData: {
      schemeName,
      eligibilityStatus,
      benefits
    }
  });
};

export const logCarbosafeActivity = async (
  farmLocation: string,
  activityType: string,
  creditsEarned: number,
  description: string
): Promise<string> => {
  const service = ActivityLogService.getInstance();
  return service.addLog({
    farmLocation,
    featureUsed: 'Carbosafe',
    activityType: 'Carbon Credit Activity',
    activityDetails: description,
    aiRemarks: `You have earned ${creditsEarned} carbon credits for ${activityType}.`,
    isAutoGenerated: true,
    additionalData: {
      activityType,
      creditsEarned
    }
  });
};

export const logManualFarmActivity = async (
  farmLocation: string,
  activityType: string,
  details: string,
  duration?: number
): Promise<string> => {
  const service = ActivityLogService.getInstance();
  return service.addLog({
    farmLocation,
    featureUsed: 'Manual Activity',
    activityType,
    activityDetails: `${details}${duration ? ` - Duration: ${duration} hours` : ''}`,
    isAutoGenerated: false,
    additionalData: {
      duration
    }
  });
};

export const logAIAssistantInteraction = async (
  farmLocation: string,
  query: string,
  response: string
): Promise<string> => {
  const service = ActivityLogService.getInstance();
  return service.addLog({
    farmLocation,
    featureUsed: 'AI Assistant',
    activityType: 'AI Query',
    activityDetails: `Asked: "${query.substring(0, 100)}${query.length > 100 ? '...' : ''}"`,
    aiRemarks: response.substring(0, 200) + (response.length > 200 ? '...' : ''),
    isAutoGenerated: true,
    additionalData: {
      fullQuery: query,
      fullResponse: response
    }
  });
};

export default ActivityLogService;